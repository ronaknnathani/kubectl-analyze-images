---
phase: 04-build-release-automation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - .github/workflows/ci.yml
  - .github/workflows/release.yml
autonomous: true

must_haves:
  truths:
    - "CI workflow runs tests and linting on every push and pull request to main"
    - "CI workflow uses Go 1.23 matching go.mod toolchain"
    - "Release workflow triggers on version tag pushes (v*) and creates GitHub release with binaries"
    - "Release workflow uses GoReleaser to build and publish multi-platform binaries"
    - "Both workflows use standard GitHub Actions (checkout, setup-go, goreleaser-action)"
  artifacts:
    - path: ".github/workflows/ci.yml"
      provides: "CI pipeline running tests and golangci-lint on PRs"
      contains: "golangci-lint"
    - path: ".github/workflows/release.yml"
      provides: "Release pipeline triggered by version tags"
      contains: "goreleaser"
  key_links:
    - from: ".github/workflows/ci.yml"
      to: ".golangci.yml"
      via: "golangci-lint-action reads config from .golangci.yml"
      pattern: "golangci-lint"
    - from: ".github/workflows/release.yml"
      to: ".goreleaser.yaml"
      via: "goreleaser-action reads config from .goreleaser.yaml"
      pattern: "goreleaser"
---

<objective>
Create GitHub Actions workflows for continuous integration (test + lint on PRs) and automated releases (GoReleaser on version tags).

Purpose: Automate the CI/CD pipeline so every pull request is validated with tests and linting, and every version tag automatically produces a GitHub release with multi-platform binaries and checksums. This is essential for professional open-source distribution via krew.

Output: `.github/workflows/ci.yml` and `.github/workflows/release.yml`.
</objective>

<execution_context>
@/Users/rnathani/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rnathani/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create .github/workflows/ci.yml for test and lint on PRs</name>
  <files>.github/workflows/ci.yml</files>
  <action>
Create the directory `.github/workflows/` if it does not exist, then create `.github/workflows/ci.yml`:

```yaml
name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

permissions:
  contents: read

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod

      - name: Download dependencies
        run: go mod download

      - name: Run tests
        run: go test -race -coverprofile=coverage.out ./...

      - name: Show coverage
        run: go tool cover -func=coverage.out

  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod

      - name: Run golangci-lint
        uses: golangci/golangci-lint-action@v6
        with:
          version: latest

  build:
    name: Build
    runs-on: ubuntu-latest
    needs: [test, lint]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod

      - name: Build binary
        run: go build -o kubectl-analyze-images ./cmd/kubectl-analyze-images

      - name: Verify binary
        run: ./kubectl-analyze-images --version
```

Key design decisions:
- **go-version-file: go.mod** reads Go version from go.mod instead of hardcoding, so it stays in sync automatically
- **Test job** uses `-race` flag to detect race conditions and generates coverage report
- **Lint job** uses the official `golangci/golangci-lint-action@v6` which handles caching and version management; it reads `.golangci.yml` automatically
- **Build job** depends on test+lint passing first (gate), verifies the binary actually runs
- **Test and Lint run in parallel** for faster CI (both are independent)
- **permissions: contents: read** follows principle of least privilege
- NOT using matrix builds (single Go version is sufficient; multi-version is unnecessary for a kubectl plugin)
- NOT caching go modules manually (setup-go@v5 handles module caching automatically)
  </action>
  <verify>Verify the file is valid YAML: `python3 -c "import yaml; yaml.safe_load(open('.github/workflows/ci.yml'))"`. Verify it contains triggers for push and pull_request to main. Verify it has test, lint, and build jobs. Verify golangci-lint-action version is v6. Verify go-version-file is set to go.mod.</verify>
  <done>.github/workflows/ci.yml exists with three jobs: test (go test -race with coverage), lint (golangci-lint-action v6), and build (compile and verify binary). Triggers on push/PR to main. Uses go-version-file for automatic Go version sync. Test and lint run in parallel, build gates on both.</done>
</task>

<task type="auto">
  <name>Task 2: Create .github/workflows/release.yml for automated releases on tags</name>
  <files>.github/workflows/release.yml</files>
  <action>
Create `.github/workflows/release.yml`:

```yaml
name: Release

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write

jobs:
  release:
    name: Release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod

      - name: Run tests
        run: go test -race ./...

      - name: Run GoReleaser
        uses: goreleaser/goreleaser-action@v6
        with:
          distribution: goreleaser
          version: "~> v2"
          args: release --clean
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

Key design decisions:
- **Triggers on `v*` tags only** (e.g., v1.0.0, v1.1.0-beta.1)
- **fetch-depth: 0** is required for GoReleaser to generate changelog from git history
- **permissions: contents: write** is required for GoReleaser to create GitHub releases and upload assets
- **Tests run before release** as a safety gate (should have passed in CI, but re-run to be sure)
- **goreleaser-action@v6** is the current version of the official action
- **version: "~> v2"** pins to GoReleaser v2.x (matches our `version: 2` config)
- **`--clean`** removes previous dist/ before building
- **GITHUB_TOKEN** is automatically provided by GitHub Actions, no manual secret needed
- **go-version-file: go.mod** ensures release builds use same Go version as development
- NOT running linting in release workflow (already gated by CI on the commit/PR that was merged)
- NOT using separate jobs for build/publish (GoReleaser handles both atomically)
  </action>
  <verify>Verify the file is valid YAML: `python3 -c "import yaml; yaml.safe_load(open('.github/workflows/release.yml'))"`. Verify it triggers on `v*` tag push only. Verify it uses goreleaser-action@v6 with version "~> v2". Verify fetch-depth is 0. Verify GITHUB_TOKEN is passed as env var. Verify permissions include contents: write.</verify>
  <done>.github/workflows/release.yml exists with single release job triggered on v* tags. Uses goreleaser-action v6 with GoReleaser v2, fetch-depth 0 for changelog, tests before release as safety gate, GITHUB_TOKEN for publishing. Creates GitHub release with multi-platform binaries and checksums automatically.</done>
</task>

</tasks>

<verification>
1. `.github/workflows/ci.yml` exists and is valid YAML
2. CI triggers on push and pull_request to main branch
3. CI has test, lint, and build jobs
4. CI test job uses `-race` flag and generates coverage
5. CI lint job uses `golangci/golangci-lint-action@v6`
6. CI build job depends on test and lint
7. `.github/workflows/release.yml` exists and is valid YAML
8. Release triggers only on `v*` tag pushes
9. Release uses `goreleaser/goreleaser-action@v6` with version `~> v2`
10. Release has `fetch-depth: 0` for changelog generation
11. Release passes `GITHUB_TOKEN` as env var
12. Both workflows use `go-version-file: go.mod` for Go version
</verification>

<success_criteria>
- CI workflow validates every PR with tests, linting, and build verification
- Release workflow automatically creates GitHub releases with binaries on version tags
- Both workflows use current action versions (checkout@v4, setup-go@v5, golangci-lint@v6, goreleaser@v6)
- Go version derived from go.mod (not hardcoded)
- Release workflow has correct permissions and fetch-depth for GoReleaser
- All workflow files are valid YAML
</success_criteria>

<output>
After completion, create `.planning/phases/04-build-release-automation/04-02-SUMMARY.md`
</output>
