---
phase: 03-plugin-restructuring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/plugin/options.go
  - cmd/kubectl-analyze-images/main.go
autonomous: true

must_haves:
  truths:
    - "AnalyzeOptions struct has Complete/Validate/Run methods following kubectl plugin pattern"
    - "Complete populates defaults for unset fields (output=table, topImages=25, showHistogram=true)"
    - "Validate rejects invalid output format and invalid topImages values"
    - "Run orchestrates the full pipeline: create cluster client -> create analyzer -> analyze -> report"
    - "main.go is a thin CLI layer that only parses flags, creates AnalyzeOptions, calls Complete/Validate/Run"
    - "main.go has no business logic (no analysis calls, no reporter calls, no namespace display logic)"
    - "All existing features still work: table output, JSON output, histograms, filtering, top-images, no-color"
    - "All dependencies injected into AnalyzeOptions (kubernetes.Interface, io.Writer)"
  artifacts:
    - path: "pkg/plugin/options.go"
      provides: "AnalyzeOptions with Complete/Validate/Run pattern"
      contains: "func (o *AnalyzeOptions) Run"
      exports: ["AnalyzeOptions"]
    - path: "cmd/kubectl-analyze-images/main.go"
      provides: "Thin CLI layer with cobra command and flag binding"
      contains: "o.Complete"
  key_links:
    - from: "pkg/plugin/options.go"
      to: "pkg/kubernetes/interface.go"
      via: "AnalyzeOptions holds kubernetes.Interface field"
      pattern: "KubernetesClient kubernetes\\.Interface"
    - from: "pkg/plugin/options.go"
      to: "internal/cluster/client.go"
      via: "Run creates cluster.Client from kubernetes.Interface"
      pattern: "cluster\\.NewClient"
    - from: "pkg/plugin/options.go"
      to: "internal/analyzer/pod_analyzer.go"
      via: "Run creates PodAnalyzer from cluster.Client"
      pattern: "analyzer\\.NewPodAnalyzer"
    - from: "pkg/plugin/options.go"
      to: "internal/reporter/report.go"
      via: "Run creates Reporter and generates report"
      pattern: "reporter\\.NewReporter"
    - from: "cmd/kubectl-analyze-images/main.go"
      to: "pkg/plugin/options.go"
      via: "main creates AnalyzeOptions from flags, calls Complete/Validate/Run"
      pattern: "plugin\\.AnalyzeOptions"
---

<objective>
Create the plugin options struct with Complete/Validate/Run pattern and refactor main.go to be a thin CLI layer.

Purpose: Establish the kubectl-standard plugin architecture where all business logic lives in `pkg/plugin/options.go` and `main.go` only handles CLI parsing and flag binding. This separates concerns cleanly: the plugin package is testable and reusable, while main.go is minimal boilerplate.

Output: `pkg/plugin/options.go` with full pipeline orchestration, and a refactored `cmd/kubectl-analyze-images/main.go` under 80 lines with zero business logic.
</objective>

<execution_context>
@/Users/rnathani/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rnathani/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-kubernetes-abstraction-layer/02-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pkg/plugin/options.go with Complete/Validate/Run pattern</name>
  <files>pkg/plugin/options.go</files>
  <action>
Create `pkg/plugin/options.go` in package `plugin`.

**AnalyzeOptions struct:**

```go
package plugin

import (
    "context"
    "fmt"
    "io"
    "os"

    "github.com/ronaknnathani/kubectl-analyze-images/internal/analyzer"
    "github.com/ronaknnathani/kubectl-analyze-images/internal/cluster"
    "github.com/ronaknnathani/kubectl-analyze-images/internal/reporter"
    "github.com/ronaknnathani/kubectl-analyze-images/pkg/kubernetes"
    "github.com/ronaknnathani/kubectl-analyze-images/pkg/types"
)

// AnalyzeOptions holds all the configuration and dependencies for running image analysis.
// It follows the kubectl plugin Complete/Validate/Run pattern.
type AnalyzeOptions struct {
    // CLI flags
    Namespace     string
    LabelSelector string
    OutputFormat  string
    NoColor       bool
    TopImages     int
    KubeContext   string
    ShowHistogram bool

    // Injected dependencies
    KubernetesClient kubernetes.Interface
    Out              io.Writer
    ErrOut           io.Writer
}
```

**Complete method** — populate defaults and create kubernetes client if not already injected:

```go
func (o *AnalyzeOptions) Complete() error {
    // Set defaults for unset fields
    if o.OutputFormat == "" {
        o.OutputFormat = "table"
    }
    if o.TopImages == 0 {
        o.TopImages = 25
    }
    if o.Out == nil {
        o.Out = os.Stdout
    }
    if o.ErrOut == nil {
        o.ErrOut = os.Stderr
    }

    // Create kubernetes client if not injected (production path)
    if o.KubernetesClient == nil {
        k8sClient, err := kubernetes.NewClient(o.KubeContext)
        if err != nil {
            return fmt.Errorf("failed to create kubernetes client: %w", err)
        }
        o.KubernetesClient = k8sClient
    }

    return nil
}
```

The key design: `KubernetesClient` is nil by default from CLI usage, so Complete creates it. But tests can pre-inject a FakeClient, and Complete skips creation. Same for Out/ErrOut — defaults to os.Stdout/Stderr but tests inject bytes.Buffer.

**Validate method** — check inputs:

```go
func (o *AnalyzeOptions) Validate() error {
    // Validate output format
    switch o.OutputFormat {
    case "table", "json":
        // valid
    default:
        return fmt.Errorf("invalid output format %q: must be \"table\" or \"json\"", o.OutputFormat)
    }

    // Validate top images count
    if o.TopImages < 1 {
        return fmt.Errorf("--top-images must be at least 1, got %d", o.TopImages)
    }

    return nil
}
```

**Run method** — orchestrate the full pipeline. Move the business logic from `runAnalyze()` in main.go here:

```go
func (o *AnalyzeOptions) Run(ctx context.Context) error {
    // Create analysis configuration
    config := types.DefaultAnalysisConfig()

    // Create cluster client with injected kubernetes interface
    clusterClient := cluster.NewClient(o.KubernetesClient)

    // Create analyzer with injected cluster client
    podAnalyzer := analyzer.NewPodAnalyzer(clusterClient, config)

    // Display analysis parameters
    namespaceDisplay := o.Namespace
    if namespaceDisplay == "" {
        namespaceDisplay = "All"
    }
    fmt.Fprintf(o.Out, "Analyzing images in namespace: %s\n", namespaceDisplay)
    if o.LabelSelector != "" {
        fmt.Fprintf(o.Out, "Using label selector: %s\n", o.LabelSelector)
    }
    fmt.Fprintln(o.Out)

    // Run analysis
    analysis, err := podAnalyzer.AnalyzePods(ctx, o.Namespace, o.LabelSelector)
    if err != nil {
        return fmt.Errorf("failed to analyze pods: %w", err)
    }

    // Generate report
    rep := reporter.NewReporter(o.OutputFormat)
    rep.SetNoColor(o.NoColor)
    rep.SetTopImages(o.TopImages)
    if err := rep.GenerateReport(analysis); err != nil {
        return fmt.Errorf("failed to generate report: %w", err)
    }

    return nil
}
```

**IMPORTANT design decisions:**

1. **Reporter still writes to os.Stdout directly** via `reporter.GenerateReport` which calls `printer.Print(os.Stdout, ...)`. In a future phase, the Reporter could accept `io.Writer`, but for now we preserve the existing behavior. The `o.Out` writer is used for the pre-analysis status messages ("Analyzing images in namespace: ..."). This matches the current behavior where status messages go to stdout and spinner goes to stderr.

2. **ShowHistogram is not passed through** because the Reporter already defaults `showHistogram: true` in `NewReporter`. The current CLI has no flag to disable histograms. Keep it as a field on AnalyzeOptions for future use but don't wire it yet.

3. **The spinner/UX code stays in cluster client and analyzer** — Run does not touch spinner logic.

4. **AnalysisConfig stays with default values** — `PodPageSize: 500`. No CLI flag for this yet.
  </action>
  <verify>Run `go build ./pkg/plugin/...` — must compile with zero errors. Run `go vet ./pkg/plugin/...` — must pass. Verify the file exports AnalyzeOptions with Complete, Validate, and Run methods.</verify>
  <done>pkg/plugin/options.go exists with AnalyzeOptions struct. Complete populates defaults and creates kubernetes client when not injected. Validate checks output format and topImages. Run orchestrates the full analysis pipeline using injected dependencies. All three methods compile without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Refactor main.go to thin CLI layer using AnalyzeOptions</name>
  <files>cmd/kubectl-analyze-images/main.go</files>
  <action>
Rewrite `cmd/kubectl-analyze-images/main.go` to be a thin CLI layer. The new main.go should:

1. Create an `AnalyzeOptions` struct
2. Bind cobra flags directly to its fields
3. In RunE: call `o.Complete()` then `o.Validate()` then `o.Run(ctx)`
4. No business logic — no analyzer creation, no reporter calls, no namespace display

**New main.go (target: under 80 lines):**

```go
package main

import (
    "context"
    "fmt"
    "os"

    "github.com/ronaknnathani/kubectl-analyze-images/pkg/plugin"
    "github.com/spf13/cobra"
)

var (
    version = "0.1.0"
    commit  = "unknown"
    date    = "unknown"
)

func main() {
    o := &plugin.AnalyzeOptions{}

    rootCmd := &cobra.Command{
        Use:   "kubectl-analyze-images",
        Short: "Analyze container images from Kubernetes pods",
        Long: `A kubectl plugin to analyze container images from pods in Kubernetes clusters.
It extracts image sizes from node status and generates reports with performance metrics.`,
        Version: fmt.Sprintf("%s (commit: %s, date: %s)", version, commit, date),
        RunE: func(cmd *cobra.Command, args []string) error {
            if err := o.Complete(); err != nil {
                return err
            }
            if err := o.Validate(); err != nil {
                return err
            }
            return o.Run(context.Background())
        },
    }

    // Bind flags directly to AnalyzeOptions fields
    rootCmd.Flags().StringVarP(&o.Namespace, "namespace", "n", "", "Target namespace (default: all namespaces)")
    rootCmd.Flags().StringVarP(&o.LabelSelector, "selector", "l", "", "Label selector for pods")
    rootCmd.Flags().StringVarP(&o.OutputFormat, "output", "o", "table", "Output format: table, json")
    rootCmd.Flags().BoolVar(&o.NoColor, "no-color", false, "Disable colored output (default: false)")
    rootCmd.Flags().IntVar(&o.TopImages, "top-images", 25, "Number of top images to show in the report (default: 25)")
    rootCmd.Flags().StringVar(&o.KubeContext, "context", "", "Kubernetes context to use (default: current context)")

    if err := rootCmd.Execute(); err != nil {
        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
        os.Exit(1)
    }
}
```

**Key changes from current main.go:**

- REMOVED: `runAnalyze` function entirely (logic moved to `pkg/plugin/options.go` Run method)
- REMOVED: imports for `internal/analyzer`, `internal/cluster`, `internal/reporter`, `pkg/kubernetes`, `pkg/types`
- ADDED: import for `pkg/plugin`
- CHANGED: `runAnalyze(namespace, labelSelector, ...)` call replaced with `o.Complete() -> o.Validate() -> o.Run(ctx)`
- CHANGED: Flags bind to `o.Namespace`, `o.LabelSelector`, etc. instead of local variables
- PRESERVED: version/commit/date variables, cobra command structure, flag names and defaults, error handling with os.Exit(1)

**Verification checklist for main.go:**
- [ ] No imports of internal/analyzer, internal/cluster, internal/reporter, pkg/kubernetes, pkg/types
- [ ] Only import is pkg/plugin (plus context, fmt, os, cobra)
- [ ] No `runAnalyze` function exists
- [ ] RunE calls o.Complete() -> o.Validate() -> o.Run(ctx) in sequence
- [ ] Flags bind to o.FieldName, not local variables
- [ ] File is under 80 lines
- [ ] `go build ./cmd/...` compiles without errors
  </action>
  <verify>Run `go build ./...` — must compile with zero errors. Run `go vet ./...` — must pass. Run `go test ./...` — all existing tests must pass (no regressions). Count lines: `wc -l cmd/kubectl-analyze-images/main.go` — must be under 80 lines. Verify no imports of internal packages in main.go: `grep -c 'internal/' cmd/kubectl-analyze-images/main.go` should be 0.</verify>
  <done>main.go is under 80 lines. Contains only cobra command setup and flag binding. No business logic, no internal package imports. RunE delegates to AnalyzeOptions Complete/Validate/Run. All existing tests pass. `go build ./...` and `make build` succeed. Binary produces same output as before.</done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles the entire project without errors
2. `go vet ./...` passes
3. `go test ./...` passes — all tests (Phase 1 + Phase 2) green, no regressions
4. `make build` succeeds
5. `pkg/plugin/options.go` exports AnalyzeOptions with Complete, Validate, Run methods
6. `cmd/kubectl-analyze-images/main.go` is under 80 lines
7. main.go has no imports from `internal/` packages
8. main.go has no `runAnalyze` function
9. AnalyzeOptions.Complete creates kubernetes client when KubernetesClient is nil
10. AnalyzeOptions.Validate rejects invalid output formats ("yaml", "xml", etc.)
11. AnalyzeOptions.Run creates cluster client -> analyzer -> runs analysis -> generates report
</verification>

<success_criteria>
- Plugin follows Complete/Validate/Run kubectl standard pattern
- main.go is thin CLI layer with no business logic (under 80 lines)
- All dependencies injectable (KubernetesClient, Out, ErrOut can be set by tests)
- All existing features still work (table, JSON, histograms, filtering, top-images, no-color)
- All Phase 1 and Phase 2 tests pass without modification
- `make build` produces working binary
</success_criteria>

<output>
After completion, create `.planning/phases/03-plugin-restructuring/03-01-SUMMARY.md`
</output>
