---
phase: 02-kubernetes-abstraction-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/kubernetes/interface.go
  - pkg/kubernetes/client.go
  - pkg/kubernetes/fake.go
autonomous: true

must_haves:
  truths:
    - "kubernetes.Interface defines ListPods and ListNodes methods with context.Context"
    - "kubernetes.NewClient(contextName) returns Interface backed by real clientset"
    - "kubernetes.NewFakeClient(objects...) returns Interface backed by fake clientset"
    - "Both implementations satisfy the same interface and compile without errors"
  artifacts:
    - path: "pkg/kubernetes/interface.go"
      provides: "Interface type with ListPods and ListNodes"
      contains: "type Interface interface"
    - path: "pkg/kubernetes/client.go"
      provides: "Real Kubernetes client implementation"
      exports: ["NewClient"]
    - path: "pkg/kubernetes/fake.go"
      provides: "Fake Kubernetes client for testing"
      exports: ["NewFakeClient"]
  key_links:
    - from: "pkg/kubernetes/client.go"
      to: "pkg/kubernetes/interface.go"
      via: "Client struct implements Interface"
      pattern: "func \\(c \\*Client\\) ListPods"
    - from: "pkg/kubernetes/fake.go"
      to: "pkg/kubernetes/interface.go"
      via: "FakeClient struct implements Interface"
      pattern: "func \\(f \\*FakeClient\\) ListPods"
---

<objective>
Create the Kubernetes interface abstraction layer with real and fake client implementations.

Purpose: Establish the interface contract that all Kubernetes API interactions will flow through, enabling testability via dependency injection. This is the foundation that Plan 02 refactors consumers to depend on.

Output: Three files in `pkg/kubernetes/` — interface definition, real client wrapper, and fake client for testing.
</objective>

<execution_context>
@/Users/rnathani/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rnathani/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-kubernetes-abstraction-layer/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Kubernetes interface and real client implementation</name>
  <files>pkg/kubernetes/interface.go, pkg/kubernetes/client.go</files>
  <action>
Create `pkg/kubernetes/interface.go` defining the Interface:

```go
package kubernetes

import (
    "context"
    corev1 "k8s.io/api/core/v1"
    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// Interface defines the contract for Kubernetes cluster operations.
// Both real and fake implementations satisfy this interface.
type Interface interface {
    ListPods(ctx context.Context, namespace string, opts metav1.ListOptions) (*corev1.PodList, error)
    ListNodes(ctx context.Context, opts metav1.ListOptions) (*corev1.NodeList, error)
}
```

Create `pkg/kubernetes/client.go` implementing the real client:

- Define `Client` struct with `clientset *kubernetes.Clientset` and `config *rest.Config` fields.
- Constructor `NewClient(contextName string) (Interface, error)` — loads kubeconfig using `clientcmd.NewDefaultClientConfigLoadingRules()` and `clientcmd.NewNonInteractiveDeferredLoadingClientConfig()`, creates clientset via `kubernetes.NewForConfig(config)`. If `contextName` is not empty, set `configOverrides.CurrentContext`. Return `Interface`, not `*Client`.
- `ListPods(ctx, namespace, opts)` delegates to `c.clientset.CoreV1().Pods(namespace).List(ctx, opts)`.
- `ListNodes(ctx, opts)` delegates to `c.clientset.CoreV1().Nodes().List(ctx, opts)`.

This mirrors the kubeconfig loading logic currently in `internal/cluster/client.go` `NewClient()` (lines 28-51). The key difference: this returns `Interface` not a concrete type.

Do NOT include spinner/progress logic here — that stays in `internal/cluster/client.go` (Plan 02).
  </action>
  <verify>Run `go build ./pkg/kubernetes/...` — must compile with zero errors. Run `go vet ./pkg/kubernetes/...` — must pass.</verify>
  <done>Interface defined with ListPods and ListNodes. Real Client struct implements Interface. Constructor returns Interface type. Both methods delegate to clientset.</done>
</task>

<task type="auto">
  <name>Task 2: Create fake client implementation for testing</name>
  <files>pkg/kubernetes/fake.go</files>
  <action>
Create `pkg/kubernetes/fake.go`:

- Define `FakeClient` struct with `clientset *fake.Clientset` field (import `k8s.io/client-go/kubernetes/fake`).
- Constructor `NewFakeClient(objects ...runtime.Object) Interface` — wraps `fake.NewSimpleClientset(objects...)`. Returns `Interface` (not `*FakeClient`). Import `k8s.io/apimachinery/pkg/runtime` for `runtime.Object`.
- `ListPods(ctx, namespace, opts)` delegates to `f.clientset.CoreV1().Pods(namespace).List(ctx, opts)`.
- `ListNodes(ctx, opts)` delegates to `f.clientset.CoreV1().Nodes().List(ctx, opts)`.

The implementation mirrors the real Client but wraps `fake.Clientset` instead of `kubernetes.Clientset`. This gives us a test double that handles List, label selectors, namespace filtering, and pagination automatically — no custom mock logic needed.

Verify that `NewFakeClient` with no arguments returns a valid client (empty results), and that the compile-time interface check passes. Add a compile-time assertion at file level:

```go
var _ Interface = (*FakeClient)(nil)
```

Also add the same assertion in `client.go`:

```go
var _ Interface = (*Client)(nil)
```
  </action>
  <verify>Run `go build ./pkg/kubernetes/...` — must compile. Run `go vet ./pkg/kubernetes/...` — must pass. The compile-time interface assertions confirm both types implement Interface.</verify>
  <done>FakeClient wraps fake.Clientset, implements Interface. NewFakeClient accepts runtime.Object variadic args. Compile-time assertions prove both Client and FakeClient satisfy Interface.</done>
</task>

</tasks>

<verification>
1. `go build ./pkg/kubernetes/...` compiles without errors
2. `go vet ./pkg/kubernetes/...` passes
3. Three files exist: `pkg/kubernetes/interface.go`, `pkg/kubernetes/client.go`, `pkg/kubernetes/fake.go`
4. Interface has exactly two methods: ListPods, ListNodes
5. Both Client and FakeClient have compile-time interface assertions (`var _ Interface = ...`)
6. NewClient returns `(Interface, error)`, NewFakeClient returns `Interface`
</verification>

<success_criteria>
- `pkg/kubernetes/` package compiles and exports Interface, NewClient, NewFakeClient
- Real client wraps kubernetes.Clientset with kubeconfig loading
- Fake client wraps fake.Clientset for zero-dependency testing
- No spinner or UI logic in this package (pure API abstraction)
- `go build ./...` still passes (no breakage to rest of project)
</success_criteria>

<output>
After completion, create `.planning/phases/02-kubernetes-abstraction-layer/02-01-SUMMARY.md`
</output>
