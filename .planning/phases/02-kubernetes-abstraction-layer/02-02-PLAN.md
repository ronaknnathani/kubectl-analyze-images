---
phase: 02-kubernetes-abstraction-layer
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - internal/cluster/client.go
  - internal/cluster/client_test.go
  - internal/analyzer/pod_analyzer.go
  - internal/analyzer/pod_analyzer_test.go
  - cmd/kubectl-analyze-images/main.go
autonomous: true

must_haves:
  truths:
    - "All Kubernetes API calls go through kubernetes.Interface (no direct clientset usage in cluster or analyzer)"
    - "cluster.NewClient accepts kubernetes.Interface, not a context string"
    - "analyzer.NewPodAnalyzer accepts *cluster.Client, not creating one internally"
    - "main.go creates kubernetes client, injects into cluster client, injects into analyzer"
    - "FakeClient enables full unit testing of cluster and analyzer without real cluster"
    - "Spinner/progress UX in cluster client is unchanged"
    - "Test coverage for core logic in internal/cluster and internal/analyzer packages exceeds 60% (spinner/UX lines covered incidentally, not the coverage target)"
  artifacts:
    - path: "internal/cluster/client.go"
      provides: "Cluster client accepting kubernetes.Interface"
      contains: "k8sClient kubernetes.Interface"
    - path: "internal/cluster/client_test.go"
      provides: "Unit tests for cluster client using FakeClient"
      contains: "NewFakeClient"
    - path: "internal/analyzer/pod_analyzer.go"
      provides: "Analyzer accepting *cluster.Client via constructor"
      contains: "func NewPodAnalyzer(clusterClient *cluster.Client"
    - path: "internal/analyzer/pod_analyzer_test.go"
      provides: "Unit tests for analyzer using FakeClient"
      contains: "NewFakeClient"
    - path: "cmd/kubectl-analyze-images/main.go"
      provides: "Dependency injection wiring"
      contains: "kubernetes.NewClient"
  key_links:
    - from: "internal/cluster/client.go"
      to: "pkg/kubernetes/interface.go"
      via: "Client struct holds kubernetes.Interface field"
      pattern: "k8sClient kubernetes\\.Interface"
    - from: "internal/analyzer/pod_analyzer.go"
      to: "internal/cluster/client.go"
      via: "PodAnalyzer holds *cluster.Client"
      pattern: "clusterClient \\*cluster\\.Client"
    - from: "cmd/kubectl-analyze-images/main.go"
      to: "pkg/kubernetes/client.go"
      via: "Creates kubernetes.Interface via NewClient"
      pattern: "kubernetes\\.NewClient"
    - from: "cmd/kubectl-analyze-images/main.go"
      to: "internal/cluster/client.go"
      via: "Creates cluster.Client with kubernetes.Interface"
      pattern: "cluster\\.NewClient\\(k8sClient\\)"
    - from: "internal/cluster/client_test.go"
      to: "pkg/kubernetes/fake.go"
      via: "Tests use NewFakeClient for test data"
      pattern: "kubernetes\\.NewFakeClient"
---

<objective>
Refactor cluster and analyzer packages to use the Kubernetes interface abstraction, update main.go for dependency injection, and add comprehensive unit tests.

Purpose: Complete the interface-driven refactor so all Kubernetes API interactions go through `kubernetes.Interface`, making cluster and analyzer packages fully testable with `FakeClient`. This is the core value delivery of Phase 2.

Output: Refactored `internal/cluster/client.go` and `internal/analyzer/pod_analyzer.go` with dependency injection, updated `main.go` wiring, and new test files achieving >60% coverage for cluster/analyzer packages.
</objective>

<execution_context>
@/Users/rnathani/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rnathani/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-kubernetes-abstraction-layer/02-RESEARCH.md
@.planning/phases/02-kubernetes-abstraction-layer/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor cluster client, analyzer, and main.go for dependency injection</name>
  <files>internal/cluster/client.go, internal/analyzer/pod_analyzer.go, cmd/kubectl-analyze-images/main.go</files>
  <action>
**Refactor `internal/cluster/client.go`:**

1. Change the import: add `"github.com/ronaknnathani/kubectl-analyze-images/pkg/kubernetes"` (the package created in Plan 01). Remove direct imports of `k8s.io/client-go/kubernetes`, `k8s.io/client-go/rest`, `k8s.io/client-go/tools/clientcmd` — these move to `pkg/kubernetes/client.go`.

2. Change the `Client` struct:
   - FROM: `clientset *kubernetes.Clientset` and `config *rest.Config`
   - TO: `k8sClient kubernetes.Interface` (single field, no config needed here)

3. Change constructor signature:
   - FROM: `func NewClient(contextName string) (*Client, error)` (creates clientset internally)
   - TO: `func NewClient(k8sClient kubernetes.Interface) *Client` (accepts interface, no error since no kubeconfig loading)
   - Remove all kubeconfig loading logic from this constructor (it now lives in `pkg/kubernetes/client.go`)
   - Simply return `&Client{k8sClient: k8sClient}`

4. Refactor `ListPods` method:
   - Keep the same signature: `func (c *Client) ListPods(ctx context.Context, namespace, labelSelector string) ([]types.Pod, *types.PerformanceMetrics, error)`
   - Keep ALL spinner logic (create spinner, start, update, stop) — this is UX, not K8s API
   - Change the pager closure to bridge through the interface. The exact pager code becomes:
     ```go
     pager := pager.New(func(ctx context.Context, opts metav1.ListOptions) (runtime.Object, error) {
         return c.k8sClient.ListPods(ctx, namespace, opts)
     })
     ```
     This works because `*corev1.PodList` implements `runtime.Object`, so the return from `ListPods` satisfies the pager's `(runtime.Object, error)` signature. The pager provides its own `opts` (with continuation tokens for pagination); `namespace` is captured from the outer scope.
   - Keep the initial `listOptions` with `ResourceVersion: "0"` and `LabelSelector` — these are passed to `pager.EachListItem(ctx, listOptions, ...)` as the seed options.
   - Keep all types.FromK8sPod conversion, progress counting, metrics

5. Refactor `GetImageSizesFromNodes` method:
   - Keep the same signature: `func (c *Client) GetImageSizesFromNodes(ctx context.Context) (map[string]int64, *types.PerformanceMetrics, error)`
   - Keep ALL spinner logic
   - Change the pager closure to bridge through the interface. The exact pager code becomes:
     ```go
     pager := pager.New(func(ctx context.Context, opts metav1.ListOptions) (runtime.Object, error) {
         return c.k8sClient.ListNodes(ctx, opts)
     })
     ```
     Same pattern as ListPods — `*corev1.NodeList` implements `runtime.Object`.
   - Keep all image extraction logic, metrics

6. `GetUniqueImages`, `selectBestImageName`, `containsSHA`, `isHexString`, `namespaceDisplay` — keep unchanged (they don't touch clientset).

**Refactor `internal/analyzer/pod_analyzer.go`:**

1. Change `PodAnalyzer` struct — keep `clusterClient *cluster.Client` and `config *types.AnalysisConfig` fields (no change to struct).

2. Change constructor:
   - REMOVE `NewPodAnalyzer() (*PodAnalyzer, error)` (the zero-arg constructor that creates everything internally)
   - REPLACE `NewPodAnalyzerWithConfig(config *types.AnalysisConfig, contextName string) (*PodAnalyzer, error)` WITH:
     `func NewPodAnalyzer(clusterClient *cluster.Client, config *types.AnalysisConfig) *PodAnalyzer`
   - This no longer creates a cluster client — it receives one. No error return needed.
   - Simply return `&PodAnalyzer{clusterClient: clusterClient, config: config}`

3. `AnalyzePods` method — keep completely unchanged. It already calls `pa.clusterClient.ListPods(...)` and `pa.clusterClient.GetImageSizesFromNodes(...)`.

**Update `cmd/kubectl-analyze-images/main.go`:**

1. Add these exact import lines to the import block:
   ```go
   "github.com/ronaknnathani/kubectl-analyze-images/pkg/kubernetes"
   "github.com/ronaknnathani/kubectl-analyze-images/internal/cluster"
   ```
   Ensure these are added alongside the existing import `"github.com/ronaknnathani/kubectl-analyze-images/internal/analyzer"`.

2. In `runAnalyze` function, change the analyzer creation sequence:
   - FROM (lines 56-60):
     ```
     config := types.DefaultAnalysisConfig()
     analyzer, err := analyzer.NewPodAnalyzerWithConfig(config, kubeContext)
     ```
   - TO:
     ```go
     config := types.DefaultAnalysisConfig()

     k8sClient, err := kubernetes.NewClient(kubeContext)
     if err != nil {
         return fmt.Errorf("failed to create kubernetes client: %w", err)
     }

     clusterClient := cluster.NewClient(k8sClient)
     podAnalyzer := analyzer.NewPodAnalyzer(clusterClient, config)
     ```
   - CRITICAL: Rename the variable from `analyzer` to `podAnalyzer` everywhere in this function. The old code used `analyzer` as a variable name, which shadows the `analyzer` package import. The new variable name `podAnalyzer` avoids this conflict.
   - Update ALL subsequent references: `analyzer.AnalyzePods(...)` becomes `podAnalyzer.AnalyzePods(...)`. Search for every occurrence of the old variable name in `runAnalyze` and rename it.

3. Verification checklist for main.go:
   - [ ] Import block contains `"github.com/ronaknnathani/kubectl-analyze-images/pkg/kubernetes"`
   - [ ] Import block contains `"github.com/ronaknnathani/kubectl-analyze-images/internal/cluster"`
   - [ ] Variable named `podAnalyzer` (not `analyzer`) used for the PodAnalyzer instance
   - [ ] No remaining references to old `analyzer` variable (only `analyzer.` package qualifier)
   - [ ] `go build ./cmd/...` compiles without errors
  </action>
  <verify>Run `go build ./...` — must compile with zero errors. Run `go vet ./...` — must pass. Verify no imports of `k8s.io/client-go/kubernetes` remain in `internal/cluster/client.go` (only `pkg/kubernetes` interface). Verify `internal/analyzer/pod_analyzer.go` no longer imports `"github.com/ronaknnathani/kubectl-analyze-images/internal/cluster"` for creation — it accepts the client as a parameter. Actually, it still imports cluster for the type `*cluster.Client`, which is correct.</verify>
  <done>All three files compile. cluster.Client wraps kubernetes.Interface (not clientset). analyzer.NewPodAnalyzer accepts *cluster.Client parameter. main.go creates kubernetes client -> cluster client -> analyzer in dependency injection chain. No direct clientset usage in cluster or analyzer packages.</done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for cluster client and analyzer using FakeClient</name>
  <files>internal/cluster/client_test.go, internal/analyzer/pod_analyzer_test.go</files>
  <action>
**Create `internal/cluster/client_test.go`:**

Add test helpers at the top of the file:

```go
func createTestPod(name, namespace string, images ...string) *corev1.Pod {
    containers := make([]corev1.Container, len(images))
    for i, img := range images {
        containers[i] = corev1.Container{Name: fmt.Sprintf("container-%d", i), Image: img}
    }
    return &corev1.Pod{
        ObjectMeta: metav1.ObjectMeta{Name: name, Namespace: namespace},
        Spec: corev1.PodSpec{Containers: containers},
    }
}

func createTestNode(name string, images map[string]int64) *corev1.Node {
    nodeImages := make([]corev1.ContainerImage, 0, len(images))
    for imgName, size := range images {
        nodeImages = append(nodeImages, corev1.ContainerImage{
            Names: []string{imgName}, SizeBytes: size,
        })
    }
    return &corev1.Node{
        ObjectMeta: metav1.ObjectMeta{Name: name},
        Status: corev1.NodeStatus{Images: nodeImages},
    }
}
```

Write these table-driven tests (use testify `assert` and `require`):

1. **TestClient_ListPods** — Test cases:
   - "single pod in default namespace": Create 1 pod in "default", list from "default", expect 1 pod returned
   - "pods across namespaces with empty namespace (all)": Create pods in "default" and "kube-system", list with namespace="" (all), expect both pods
   - "no pods in namespace": Create pod in "default", list from "other-ns", expect 0 pods
   - "pod with multiple containers": Create pod with 2 container images, verify both images extracted
   - For each test: create fake client via `kubernetes.NewFakeClient(objects...)`, create `cluster.NewClient(fakeK8s)`, call `ListPods`, assert on returned `[]types.Pod` length and content

2. **TestClient_GetImageSizesFromNodes** — Test cases:
   - "single node with images": Create node with 2 images (different sizes), verify map has 2 entries with correct sizes
   - "multiple nodes with overlapping images": Create 2 nodes, some shared images, verify deduplication (last write wins for size)
   - "node with no images": Create node with empty image list, verify empty map returned
   - For each test: create fake client, create cluster.NewClient, call GetImageSizesFromNodes, assert on map keys and values

3. **TestClient_GetUniqueImages** — Test cases:
   - "unique images from multiple pods": Pass []types.Pod with overlapping images, verify dedup
   - "empty pod list": Pass empty slice, verify empty map
   - This function doesn't need fake client (it's pure logic), just test with types.Pod directly

4. **TestSelectBestImageName** — Test cases:
   - "prefers name without SHA": Pass ["nginx:1.21", "sha256:abc...64chars"], expect "nginx:1.21"
   - "single name returned": Pass ["nginx:1.21"], expect "nginx:1.21"
   - "empty list returns empty": Pass [], expect ""
   - Note: `selectBestImageName` is unexported, so test it indirectly through `GetImageSizesFromNodes` if needed, OR test it directly since tests are in same package (`package cluster`)

**IMPORTANT — Spinner code and test coverage:**

The `ListPods` and `GetImageSizesFromNodes` methods contain significant spinner/progress UX code (~30-40 lines each) that writes to stderr. Key points:

1. **Tests still work:** Spinner writes to stderr don't affect return values — the tests will pass even with spinner output appearing in test logs.
2. **Coverage accounting:** The spinner lines (create, start, update suffix, stop, fmt.Fprintf success messages) will show as "covered" in coverage reports because the test execution flows through them. However, if for any reason the coverage falls below 60% due to untestable spinner edge cases, the target should be interpreted as: **core business logic (API calls, data transformation, deduplication) must exceed 60% coverage**. The spinner/UX lines are not the critical paths being validated.
3. **Do NOT suppress spinners in tests** — adding test-only flags or disabling spinners adds complexity for no value. Let them write to stderr during tests. The tests validate return values, not stderr output.

**Create `internal/analyzer/pod_analyzer_test.go`:**

Write these tests:

1. **TestPodAnalyzer_AnalyzePods_WithPods** — Test:
   - Create fake client with 2 pods in "default" namespace (e.g., pod1 with "nginx:1.21", pod2 with "redis:6.2")
   - Create fake client with 1 node containing image sizes for "nginx:1.21" (100MB) and "redis:6.2" (50MB)
   - Create `cluster.NewClient(fakeK8s)`, then `analyzer.NewPodAnalyzer(clusterClient, config)`
   - Call `AnalyzePods(ctx, "default", "")`
   - Assert: result has 2 images, total size is 150MB, no error
   - Assert: both images have correct registry, tag, and size values

2. **TestPodAnalyzer_AnalyzePods_NoNamespace** — Test:
   - Create fake client with 1 node containing 3 images
   - Call `AnalyzePods(ctx, "", "")` (no namespace = use all node images)
   - Assert: result has 3 images from node status

3. **TestPodAnalyzer_AnalyzePods_MissingImageSize** — Test:
   - Create fake client with 1 pod using image "custom:latest"
   - Create fake client with 1 node that does NOT have "custom:latest" in its images
   - Assert: the image is marked as `Inaccessible: true` with `Size: 0`

After writing tests, run `go test -cover ./internal/cluster/ ./internal/analyzer/` and verify coverage exceeds 60% for each package.
  </action>
  <verify>Run `go test ./internal/cluster/ -v` — all tests pass. Run `go test ./internal/analyzer/ -v` — all tests pass. Run `go test -cover ./internal/cluster/ ./internal/analyzer/` — coverage >60% for each package. Run `go test ./...` — all project tests pass (no regressions). Run `make build` — build succeeds.</verify>
  <done>internal/cluster/client_test.go has table-driven tests for ListPods, GetImageSizesFromNodes, GetUniqueImages. internal/analyzer/pod_analyzer_test.go has tests for AnalyzePods with various scenarios. Coverage for cluster and analyzer packages exceeds 60%. All project tests pass. Build succeeds.</done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles the entire project without errors
2. `go vet ./...` passes
3. `go test ./...` passes — all tests (Phase 1 + Phase 2) green
4. `go test -cover ./internal/cluster/` shows >60% coverage
5. `go test -cover ./internal/analyzer/` shows >60% coverage
6. `make build` succeeds
7. No direct `*kubernetes.Clientset` usage in `internal/cluster/client.go` (only `kubernetes.Interface`)
8. No client creation in `internal/analyzer/pod_analyzer.go` (only parameter acceptance)
9. `main.go` has 3-step dependency injection: kubernetes.NewClient -> cluster.NewClient -> analyzer.NewPodAnalyzer
</verification>

<success_criteria>
- All Kubernetes API interactions go through kubernetes.Interface
- cluster.Client wraps kubernetes.Interface, preserves spinner/UX logic
- analyzer.PodAnalyzer accepts *cluster.Client via dependency injection
- main.go wires dependencies: k8s client -> cluster client -> analyzer
- Unit tests cover ListPods, GetImageSizesFromNodes, GetUniqueImages, AnalyzePods
- Test coverage >60% for internal/cluster and internal/analyzer packages
- All existing tests still pass (no regressions)
- `make build` produces working binary
</success_criteria>

<output>
After completion, create `.planning/phases/02-kubernetes-abstraction-layer/02-02-SUMMARY.md`
</output>
